(in-package #:wind-loads)

(defun index1-func(vector z)
;функция возвращает первый (нижний) индекс вектора интервала значений для интерполяции 
;пример вызова (index1-func (vector 0 1 2 3 4 5) 3.5) => 3
  (dotimes (x (- (array-total-size vector) 1))
    (setf x1 (aref vector x))
    (setf x2 (aref vector (+ x 1)))
    (if (and (<= x1 z)(<= z x2 )) 
        (progn
          (setf index1 x)
          (return-from index1-func index1)))
    )
)

(defun lin-interpol (y x p);x - это похоже вектор иксов, y - вектор значений функции , p - это параметр от которого надо найти значение функции
;пример возможного вызова (lin-interpol (vector 2 3 4.5 9 13)(vector 0 1 2 3 4) 2.1)
  (if (< p (aref x 0)) (setq p (aref x 0)))
  (if (> p (aref x (- (length x) 1))) (setq p (aref x (- (length x) 1))))
  (setq index1 (index1-func x p)
        y1 (aref y index1)
        y2 (aref y (+ index1 1))
        x1 (aref x index1)
        x2 (aref x (+ index1 1))
        k (+ y1 (* (/(- y2 y1)(- x2 x1))(- p x1))))
  (values k)
  )
(defun plosk-interpol (x y massive px py)
;параметрами функции являются вектора х у и massive, и  значения (параметры px py)внутри интервалов по х и у  
 (setq i (index1-func x  px))
 (setq j (index1-func y  py))
 (setq x1 (aref x i))
 (setq x2 (aref x (+ i 1)))
 (setq y1 (aref massive j i))
 (setq y2 (aref massive j (+ i 1)))
 (setq k1 (+ y1 (* (/(- y2 y1)(- x2 x1))(- px x1))))
 (setq y1 (aref massive (+ j 1) i))
 (setq y2 (aref massive (+ j 1) (+ i 1)))
 (setq k2 (+ y1 (* (/(- y2 y1)(- x2 x1))(- px x1))))
 (setq x1 (aref y j))
 (setq x2 (aref y (+ j 1)))
 (setq k (+ k1 (* (/(- k2 k1)(- x2 x1))(- py x1))))
 (values k)
 )
