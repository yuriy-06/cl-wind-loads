(in-package :wind-loads)

(defvar *w* (* 0.038 1.4))
(defvar *c* 1.4)

;;(defclass kolonna ()  ;; определен ранее в других функциях
;;  ((h :accessor h :initarg :h :initform 0.3)
;;   (b :accessor b :initarg :b :initform 0.15)))
(defclass svayz ()
  ((h :accessor h :initarg :h :initform 0.11)))
(defclass plosk-opora ()
  ((z-list :accessor z-list :initarg :z-list :initform nil)
   (k-list :accessor k-list)
   (dh :accessor dh-opora)
   (sin-list :accessor sin-list)
   (l-sv-list :accessor l-sv-list)
   (x-wind-list :accessor x-wind-list)
   (y-wind-list :accessor y-wind-list)
   (b :accessor b :initarg :b :initform 3)
   (kolonna :accessor kolonna :initarg :kolonna :initform nil)
   (svayz* :accessor svayz* :initarg :svayz* :initform nil)))

(defun wind-x (&key h sinx h-k h-sv k c)
  (let (w a)
    (setf a (+ (* h-k h) (* h-sv h sinx))
	  w (* *w* k c a))))
			
(defun wind-y (&key h h-k h-sv l-sv k c)
  (let (w a)
    (setf a (+ (* h h-k) (* l-sv h-sv))
	  w (* *w* k c a))))
	
(defmethod wind-plosk-opora ((obj1 plosk-opora))   ;;надо добавить ветер от распорки ;; попробуй переписать метод
  (let ((i 0) m m2 m3 sin-v l-sv wx wy tan-v alfa-v)
  (declare (optimize (debug 3)))
  (break "1")
    (dolist (x (z-list obj1))
      (progn (push (- x i) m)
	     (setf i x)))
    (setf (dh-opora obj1) (reverse m))
	(break "value m is ~a " m)
    (setf m (dh-opora obj1))
	 (break "2")
    (dolist (x m)
      (progn (setf tan-v (/ x (/ (b obj1) 2))
		   alfa-v (atan tan-v)
		   sin-v (sin alfa-v)
		   l-sv (sqrt (+ (expt x 2) (expt (/ (b obj1) 2) 2))))
	     (push sin-v m2)
	     (push l-sv m3)))
    (setf (sin-list obj1) (reverse m2)
	  (l-sv-list obj1) (reverse m3)
	  (k-list obj1) (veter-k-list* *tip-m* (z-list obj1))
	  m nil m2 nil)
    (dotimes (i (length (z-list obj1))) 
      (progn (setf wx (ocrugl-1.000 (wind-x :h (nth i (dh-opora obj1)) :sinx (nth i (sin-list obj1)) 
					    :h-k (h (kolonna obj1)) :h-sv (h (svayz* obj1)) :k (nth i (k-list obj1))  :c *c*))
		   wy (ocrugl-1.000 (wind-y :h (nth i (dh-opora obj1)) :l-sv (nth i (l-sv-list obj1)) 
					    :h-k (b (kolonna obj1)) :h-sv (h (svayz* obj1)) :k (nth i (k-list obj1))  :c *c*)))
	     (push wx m)
	     (push wy m2)))
    (setf (x-wind-list obj1) (reverse m) (y-wind-list obj1) (reverse m2))
    (format t "~a~%" "Нагрузка вдоль Х (продольное направление к плоской опоре)")	
    (format t "~a~%" (x-wind-list obj1))
    (format t "~a~%" "Нагрузка вдоль Y (Поперечное направление к плоской опоре)")
    (format t "~a~%" (y-wind-list obj1))))
			
(defun plosc-opora (&key z-list b h-kolonna b-kolonna h-svayz)
  ;; (plosc-opora :z-list (list 2.53 5 7.4) :b 2 :h-kolonna 0.25 :b-kolonna 0.175 :h-svayz 0.09)
  (let (op)
    (setf op (make-instance 'plosk-opora :z-list z-list :b b 
			    :kolonna 
			    (make-instance 'kolonna :h h-kolonna :b b-kolonna)
			    :svayz*
			    (make-instance 'svayz :h h-svayz)))
    (wind-plosk-opora op)))
			
